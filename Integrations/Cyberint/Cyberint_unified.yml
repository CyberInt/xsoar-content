category: Data Enrichment & Threat Intelligence
commonfields:
  id: cyberint
  version: -1
configuration:
- display: Incident type
  name: incidentType
  required: false
  type: 13
- additionalinfo: Cyberint API access token.
  display: Cyberint Access Token
  name: access_token
  required: true
  type: 4
- additionalinfo: Cyberint environment on which the services run (i.e http://{environment}.cyberint.io/...)
  display: Cyberint API Environment
  name: environment
  required: true
  type: 0
- display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- additionalinfo: Severities to fetch. If none is chosen, all severity levels will
    be returned.
  display: Fetch Severity
  name: fetch_severity
  options:
  - low
  - medium
  - high
  - very_high
  required: false
  type: 16
- additionalinfo: Statuses to fetch. If none is chosen, all statuses will be returned.
  display: Fetch Status
  name: fetch_status
  options:
  - open
  - acknowledged
  - closed
  required: false
  type: 16
- additionalinfo: Environments to fetch (comma separated). If empty, all available
    environments will be returned.
  display: Fetch Environment
  name: fetch_environment
  required: false
  type: 0
- additionalinfo: Types to fetch. If none is chosen, all types will be returned.
  display: Fetch Types
  name: fetch_type
  options:
  - refund_fraud
  - carding
  - coupon_fraud
  - money_laundering
  - victim_report
  - malicious_insider
  - extortion
  - phishing_email
  - phishing_kit
  - phishing_website
  - lookalike_domain
  - phishing_target_list
  - malicious_file
  - reconnaissance
  - automated_attack_tools
  - business_logic_bypass
  - target_list
  - official_social_media_profile
  - impersonation
  - intellectual_property_infringement
  - unauthorized_trading
  - negative_sentiment
  - fake_job_posting
  - defacement
  - compromised_pii
  - internal_information_disclosure
  - compromised_payment_cards
  - compromised_employee_credentials
  - compromised_customer_credentials
  - compromised_access_token
  - ransomware
  - exposed_web_interfaces
  - hijackable_subdomains
  - website_vulnerabilities
  - exposed_cloud_storage
  - exploitable_ports
  - mail_servers_in_blacklist
  - server_connected_to_botnet
  - email_security_issues
  - certificate_authority_issues
  - other
  required: false
  type: 16
- additionalinfo: Max number of alerts per fetch. Defaults to  the minimum 10, max
    is 100.
  defaultvalue: '10'
  display: Fetch Limit
  name: max_fetch
  required: false
  type: 0
- defaultvalue: 7 days
  display: First fetch timestamp (<number> <time unit>, e.g., 12 hours, 7 days)
  name: first_fetch
  required: false
  type: 0
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
description: Cyberint provides intelligence-driven digital risk protection. This integration
  will help your enterprise effectively consume actionable cyber alerts to increase
  your security posture.
detaileddescription: ''
display: Cyberint
name: cyberint
script:
  commands:
  - arguments:
    - default: false
      defaultValue: '1'
      description: Page number to return. Default is 1.
      isArray: false
      name: page
      required: false
      secret: false
    - default: false
      defaultValue: '10'
      description: Number of results in a page. Default is 10. Must be between 10
        and 100.
      isArray: false
      name: page_size
      required: false
      secret: false
    - default: false
      description: ISO-Formatted creation date. Get alerts created since this date
        (YYYY-MM-DDTHH:MM:SSZ).
      isArray: false
      name: created_date_from
      required: false
      secret: false
    - default: false
      description: ISO-Formatted creation date. Get alerts created before this date
        (YYYY-MM-DDTHH:MM:SSZ).
      isArray: false
      name: created_date_to
      required: false
      secret: false
    - default: false
      description: You can specify a date range to search for from the current time.
        (<number> <time unit>, e.g., 12 hours, 7 days) instead of a start/end time.
        created_date_range will overwrite created_date
      isArray: false
      name: created_date_range
      required: false
      secret: false
    - default: false
      description: ISO-Formatted modification date. Get alerts modified since this
        date (YYYY-MM-DDTHH:MM:SSZ).
      isArray: false
      name: modification_date_from
      required: false
      secret: false
    - default: false
      description: ISO-Formatted modification date. Get alerts modified before this
        date (YYYY-MM-DDTHH:MM:SSZ).
      isArray: false
      name: modification_date_to
      required: false
      secret: false
    - default: false
      description: You can specify a date range to search for from the current time.
        (<number> <time unit>, e.g., 12 hours, 7 days) instead of a start/end time.
        modified_date_range will overwrite modified_date
      isArray: false
      name: modified_date_range
      required: false
      secret: false
    - default: false
      description: Environment in which the alerts were created. Can be more than
        one.
      isArray: true
      name: environments
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: Status of the alert. Can be more than one.
      isArray: true
      name: statuses
      predefined:
      - open
      - acknowledged
      - closed
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: Severity of the alert. Can be more than one.
      isArray: true
      name: severities
      predefined:
      - low
      - medium
      - high
      - very_high
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: Type of the alert, can be more than one.
      isArray: true
      name: types
      predefined:
      - refund_fraud
      - carding
      - coupon_fraud
      - money_laundering
      - victim_report
      - malicious_insider
      - extortion
      - phishing_email
      - phishing_kit
      - phishing_website
      - lookalike_domain
      - phishing_target_list
      - malicious_file
      - reconnaissance
      - automated_attack_tools
      - business_logic_bypass
      - target_list
      - official_social_media_profile
      - impersonation
      - intellectual_property_infringement
      - unauthorized_trading
      - negative_sentiment
      - fake_job_posting
      - defacement
      - compromised_pii
      - internal_information_disclosure
      - compromised_payment_cards
      - compromised_employee_credentials
      - compromised_customer_credentials
      - compromised_access_token
      - ransomware
      - exposed_web_interfaces
      - hijackable_subdomains
      - website_vulnerabilities
      - exposed_cloud_storage
      - exploitable_ports
      - mail_servers_in_blacklist
      - server_connected_to_botnet
      - email_security_issues
      - certificate_authority_issues
      - other
      required: false
      secret: false
    deprecated: false
    description: List alerts according to parameters
    execution: false
    name: cyberint-alerts-fetch
    outputs:
    - contextPath: Cyberint.Alert.ref_id
      description: Reference ID of the alert.
      type: String
    - contextPath: Cyberint.Alert.confidence
      description: Confidence score of the alert.
      type: Number
    - contextPath: Cyberint.Alert.status
      description: Status of the alert.
      type: String
    - contextPath: Cyberint.Alert.severity
      description: Severity of the alert
      type: String
    - contextPath: Cyberint.Alert.created_by.email
      description: User which has created the alert.
      type: String
    - contextPath: Cyberint.Alert.created_date
      description: Date in which the alert was created.
      type: Date
    - contextPath: Cyberint.Alert.category
      description: Category of the alert.
      type: String
    - contextPath: Cyberint.Alert.type
      description: Type of the alert.
      type: String
    - contextPath: Cyberint.Alert.source_category
      description: Source category of the alert.
      type: String
    - contextPath: Cyberint.Alert.source
      description: Source of the alert.
      type: String
    - contextPath: Cyberint.Alert.targeted_vectors
      description: Vectors targeted by the threat.
      type: String
    - contextPath: Cyberint.Alert.targeted_brands
      description: Brands targeted by the threat.
      type: String
    - contextPath: Cyberint.Alert.related_entities
      description: Entities related to the alert.
      type: String
    - contextPath: Cyberint.Alert.impacts
      description: Impacts made by the threat.
      type: String
    - contextPath: Cyberint.Alert.acknowledged_date
      description: Date in which the alert was acknowledged.
      type: Date
    - contextPath: Cyberint.Alert.acknowledged_by.email
      description: User which has acknowledged the alert.
      type: String
    - contextPath: Cyberint.Alert.publish_date
      description: Date in which the alert was published.
      type: Date
    - contextPath: Cyberint.Alert.title
      description: Title of the alert.
      type: String
    - contextPath: Cyberint.Alert.alert_data.url
      description: URL impacted by the event.
      type: String
    - contextPath: Cyberint.Alert.alert_data.detection_reasons
      description: Reasons why a phishing event has been detected.
      type: String
    - contextPath: Cyberint.Alert.alert_data.tool_name
      description: Name of a tool used for an exploit if available.
      type: String
    - contextPath: Cyberint.Alert.alert_data.application
      description: Application affected by an event.
      type: String
    - contextPath: Cyberint.Alert.alert_data.source
      description: Source of an event if available.
      type: String
    - contextPath: Cyberint.Alert.alert_data.domain
      description: Domain related to an event if available.
      type: String
    - contextPath: Cyberint.Alert.alert_data.subdomian
      description: Subdomain related to an event if available.
      type: String
    - contextPath: Cyberint.Alert.alert_data.misconfiguration_type
      description: Type of misconfiguration for a misconfigured domain.
      type: String
    - contextPath: Cyberint.Alert.alert_data.ip
      description: IP related to an event.
      type: String
    - contextPath: Cyberint.Alert.alert_data.port
      description: Port related to an event.
      type: String
    - contextPath: Cyberint.Alert.alert_data.service
      description: Service related to an event.
      type: String
    - contextPath: Cyberint.Alert.alert_data.access_token
      description: Access token exposed in an event.
      type: String
    - contextPath: Cyberint.Alert.alert_data.access_token_type
      description: Access token exposed in an event.
      type: String
    - contextPath: Cyberint.Alert.alert_data.username
      description: Username of an account related to an event.
      type: String
    - contextPath: Cyberint.Alert.alert_data.csv.username
      description: Username of an account found in a report CSV.
      type: String
    - contextPath: Cyberint.Alert.alert_data.csv.password
      description: Password of an account found in a report CSV.
      type: String
    - contextPath: Cyberint.Alert.alert_data.email
      description: Email of an account related to an event.
      type: String
    - contextPath: Cyberint.Alert.alert_data.author_email_address
      description: Email of an author related to an event.
      type: String
    - contextPath: Cyberint.Alert.alert_data.repository_name
      description: Repository name related to an event.
      type: String
    - contextPath: Cyberint.Alert.alert_data.mail_server
      description: Mail server related to an event.
      type: String
    - contextPath: Cyberint.Alert.alert_data.blacklist_repository
      description: Blacklist repository name related to an event.
      type: String
    - contextPath: Cyberint.Alert.alert_data.screenshot
      description: Screenshot related to an event.
      type: String
    - contextPath: Cyberint.Alert.alert_data.spf_records
      description: SPF records if applicable to the event.
      type: String
    - contextPath: Cyberint.Alert.alert_data.dmarc_record
      description: DMARC records if applicable to the event.
      type: String
    - contextPath: Cyberint.Alert.alert_data.storage_link
      description: Storage link if applicable to the event.
      type: String
    - contextPath: Cyberint.Alert.alert_data.interface_type
      description: Interface type if applicable to the event.
      type: String
    - contextPath: Cyberint.Alert.alert_data.vulnerable_cname_record
      description: Vulnerable CName record if applicable to the event.
      type: String
    - contextPath: Cyberint.Alert.ioc.type
      description: Type of IOC related to the alert.
      type: String
    - contextPath: Cyberint.Alert.ioc.value
      description: Value of the IOC related to the alert.
      type: String
    - contextPath: Cyberint.Alert.ticket_id
      description: Ticket ID of the alert.
      type: String
    - contextPath: Cyberint.Alert.threat_actor
      description: Actor to the threat related to the alert.
      type: String
    - contextPath: Cyberint.Alert.modification_date
      description: Date the alert was last modified.
      type: Date
    - contextPath: Cyberint.Alert.closure_date
      description: Date the alert was closed.
      type: String
    - contextPath: Cyberint.Alert.closed_by.email
      description: User which has closed the alert.
      type: String
    - contextPath: Cyberint.Alert.closure_reason
      description: Reason for closing the alert.
      type: String
    - contextPath: Cyberint.Alert.description
      description: Description of the alert.
      type: String
    - contextPath: Cyberint.Alert.recommendation
      description: Recommendation for the alert
      type: String
    - contextPath: Cyberint.Alert.tags
      description: Tags related to the alert
      type: String
    - contextPath: Cyberint.Alert.attachments
      description: Attachments related to the alert
      type: String
  - arguments:
    - default: false
      description: Reference IDs for the alert(s)
      isArray: true
      name: alert_ref_ids
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      description: Desired status to update for the alert(s)
      isArray: false
      name: status
      predefined:
      - open
      - acknowledged
      - closed
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      description: Reason for updating the alerts status to closed. Required when
        status is closed.
      isArray: false
      name: closure_reason
      predefined:
      - resolved
      - irrelevant
      - false_positive
      required: false
      secret: false
    deprecated: false
    description: Update the status of one or more alerts.
    execution: false
    name: cyberint-alerts-status-update
    outputs:
    - contextPath: Cyberint.Alert.ref_id
      description: Reference ID of the alert.
      type: String
    - contextPath: Cyberint.Alert.status
      description: Status of the alert.
      type: String
    - contextPath: Cyberint.Alert.closure_reason
      description: Reason for updating the alert to closed if closed.
      type: String
  - arguments:
    - default: false
      description: Reference ID of the alert.
      isArray: false
      name: alert_ref_id
      required: true
      secret: false
    - default: false
      description: Attachment ID.
      isArray: false
      name: attachment_id
      required: true
      secret: false
    - default: false
      description: Attachment file name
      isArray: false
      name: attachment_name
      required: true
      secret: false
    deprecated: false
    description: Get alert attachment.
    execution: false
    name: cyberint-alerts-get-attachment
  dockerimage: demisto/python3:3.9.2.17246
  feed: false
  isfetch: true
  longRunning: false
  longRunningPort: false
  runonce: false
  script: |-
    # pylint: disable=unsubscriptable-object


    ''' IMPORTS '''
    from contextlib import closing
    import json
    import requests
    import dateparser
    from typing import Dict, List, Optional, Tuple, Iterable

    requests.packages.urllib3.disable_warnings()

    ''' CONSTANTS '''
    DATE_FORMAT = '%Y-%m-%dT%H:%M:%SZ'
    SEVERITIES = {'low': 1, 'medium': 2, 'high': 3, 'very_high': 4}
    CSV_FIELDS_TO_EXTRACT = ['Username', 'Password']


    class Client(BaseClient):
        """
        API Client to communicate with Cyberint and get alerts.
        """

        def __init__(self, base_url: str, access_token: str, verify_ssl: bool, proxy: bool):
            """
            Client for CyberInt RESTful API.

            Args:
                base_url (str): URL to access when getting alerts.
                access_token (str): Access token for authentication.
                verify_ssl (bool): specifies whether to verify the SSL certificate or not.
                proxy (bool): specifies if to use XSOAR proxy settings.
            """
            self._cookies = {'access_token': access_token}
            super().__init__(base_url=base_url, verify=verify_ssl, proxy=proxy)

        def list_alerts(self, page: Optional[str], page_size: Optional[int],
                        created_date_from: Optional[str], created_date_to: Optional[str],
                        modification_date_from: Optional[str], modification_date_to: Optional[str],
                        environments: Optional[List[str]], statuses: Optional[List[str]],
                        severities: Optional[List[str]], types: Optional[List[str]]) -> Dict:
            """
            Retrieve a list of alerts according to parameters.

            Args:
                page (str): Index of page to return.
                page_size (int): Size of the page to return.
                created_date_from (str): Minimal ISO-Formatted creation date.
                created_date_to (str): Maximal ISO-Formatted creation date.
                modification_date_from (str): Minimal ISO-Formatted modification date.
                modification_date_to (str): Maximal ISO-Formatted modification date.
                environments (list(str)): Environments in which the alerts were created.
                statuses (list(str)): Alerts statuses.
                severities (list(str)): Alerts severities.
                types (list(str)): Alerts type.

            Returns:
                response (Response): API response from Cyberint.
            """
            body = {'page': page, 'size': page_size, 'filters': {
                'created_date': {'from': created_date_from, 'to': created_date_to},
                'modification_date': {'from': modification_date_from, 'to': modification_date_to},
                'environments': environments, 'status': statuses, 'severity': severities,
                'type': types
            }}
            body = remove_empty_elements(body)
            response = self._http_request(method='POST', json_data=body, cookies=self._cookies,
                                          url_suffix='api/v1/alerts')
            return response

        def update_alerts(self, alerts: List[str], status: Optional[str],
                          closure_reason: Optional[str]) -> Dict:
            """
            Update the status of one or more alerts

            Args:
                alerts (list(str)): Reference IDs for the alert(s)
                status (str): Desired status to update for the alert(s)
                closure_reason (str): Reason for updating the alerts status to closed.

            Returns:
                response (Response): API response from Cyberint.
            """
            body = {'alert_ref_ids': alerts,
                    'data': {'status': status, 'closure_reason': closure_reason}}
            body = remove_empty_elements(body)
            response = self._http_request(method='PUT', json_data=body, cookies=self._cookies,
                                          url_suffix='api/v1/alerts/status')
            return response

        def get_csv_file(self, alert_id: str, attachment_id: str,
                         delimiter: bytes = b'\r\n') -> Iterable[str]:
            """
            Stream a CSV file attachment in order to extract data out of it.

            Args:
                alert_id (str): ID of the alert the CSV belongs to.
                attachment_id (str): ID of the specific CSV file.
                delimiter (str): Delimiter for the CSV file.

            Returns:
                row (generator(str)): Generator containing each line of the CSV.
            """
            url_suffix = f'api/v1/alerts/{alert_id}/attachments/{attachment_id}'
            with closing(self._http_request(method='GET', url_suffix=url_suffix,
                                            cookies=self._cookies, resp_type='all',
                                            stream=True)) as r:
                for line in r.iter_lines(delimiter=delimiter):
                    yield line.decode('utf-8').strip('"')

        def get_alert_attachment(self, alert_id: str, attachment_id: int):
            """
                Retrieve attachment by alert reference id and attachment internal id.

            Args:
                alert_id (str): Reference ID for the alert.
                attachment_id (str): Attachment ID

            Returns:
                response (Response): API response from Cyberint.
            """

            url_suffix = f'api/v1/alerts/{alert_id}/attachments/{attachment_id}'
            return self._http_request(method='GET',
                                      cookies=self._cookies,
                                      url_suffix=url_suffix,
                                      resp_type='response')


    def test_module(client: Client):
        """
        Test the connection to the API by sending a normal request.

        Args:
            client (Client): Cyberint API  client

        Returns:
            'ok' if test passed, anything else will fail the test.
        """
        try:
            result = client.list_alerts(*([None] * 10))
            if result:
                return 'ok'
        except DemistoException as exception:
            if 'Invalid token or token expired' in str(exception):
                error_message = 'Error verifying access token and / or environment, make sure the ' \
                                'configuration parameters are correct.'
            else:
                error_message = str(exception)
            raise DemistoException(error_message)


    def verify_input_date_format(date: Optional[str]) -> Optional[str]:
        """
        Make sure a date entered by the user is in the correct string format (with a Z at the end).

        Args:
            date (str): Date string given by the user. Can be None.

        Returns:
            str: Fixed date in the same format as the one needed by the API.
        """
        if date and not date.endswith('Z'):
            date += 'Z'
        return date


    def set_date_pair(start_date_arg: Optional[str], end_date_arg: Optional[str],
                      date_range_arg: Optional[str]) -> Tuple[Optional[str], Optional[str]]:
        """
        Calculate the date range to send to the API based on the arguments from the user.

        Args:
            start_date_arg (str): Optional start_date from the user.
            end_date_arg (str): Optional end_date from the user.
            date_range_arg (str): Optional date range from the user.

        Returns:
            start_date (str): Start date to send to the API.
            end_date (str): End date to send to the API.
        """
        if date_range_arg:
            start_date, end_date = parse_date_range(date_range=date_range_arg,
                                                    date_format=DATE_FORMAT, utc=False)
            return start_date, end_date
        min_date = datetime.fromisocalendar(2020, 2, 1)
        start_date_arg = verify_input_date_format(start_date_arg)
        end_date_arg = verify_input_date_format(end_date_arg)
        if start_date_arg and not end_date_arg:
            end_date_arg = datetime.strftime(datetime.now(), DATE_FORMAT)
        elif end_date_arg and not start_date_arg:
            start_date_arg = datetime.strftime(min_date, DATE_FORMAT)
        return start_date_arg, end_date_arg


    def extract_data_from_csv_stream(client: Client, alert_id: str,
                                     attachment_id: str, delimiter: bytes = b'\r\n') -> List[dict]:
        """
        Call the attachment download API and parse required fields.

        Args:
            client (Client): Cyberint API client.
            alert_id (str): ID of the alert the attachment belongs to.
            attachment_id (str): ID of the attachment itself.
            delimiter (bytes): Delimeter for the CSV file.

        Returns:
            list(dict): List of all the data found using the wanted fields.
        """
        first_line = True
        field_indexes = {}  # {wanted_field_name: wanted_field_index...}
        information_found = []
        for csv_line in client.get_csv_file(alert_id, attachment_id, delimiter):
            csv_line_separated = csv_line.split(',')
            if first_line:
                for field in CSV_FIELDS_TO_EXTRACT:
                    try:
                        field_indexes[field] = csv_line_separated.index(field)
                    except ValueError:
                        pass
                first_line = False
            else:
                try:
                    extracted_field_data = {field_name.lower(): csv_line_separated[field_index]
                                            for field_name, field_index in field_indexes.items()}
                    if extracted_field_data:
                        information_found.append(extracted_field_data)
                except IndexError:
                    pass
        return information_found


    def cyberint_alerts_fetch_command(client: Client, args: dict) -> CommandResults:
        """
        List alerts on cyberint according to parameters.

        Args:
            client (Client): Cyberint API client.
            args (dict): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        created_date_from, created_date_to = set_date_pair(args.get('created_date_from', None),
                                                           args.get('created_date_to', None),
                                                           args.get('created_date_range', None))
        modify_date_from, modify_date_to = set_date_pair(args.get('modification_date_from', None),
                                                         args.get('modification_date_to', None),
                                                         args.get('modification_date_range', None))
        if int(args.get('page_size', 10)) < 10 or int(args.get('page_size', 10)) > 100:
            raise DemistoException('Page size must be between 10 and 100.')
        result = client.list_alerts(args.get('page'), args.get('page_size'), created_date_from,
                                    created_date_to, modify_date_from, modify_date_to,
                                    argToList(args.get('environments')),
                                    argToList(args.get('statuses')),
                                    argToList(args.get('severities')), argToList(args.get('types')))
        alerts = result.get('alerts', [])
        outputs = []
        for alert in alerts:
            alert_csv_id = alert.get('alert_data', {}).get('csv', {}).get('id', '')
            if alert_csv_id:
                extracted_csv_data = extract_data_from_csv_stream(client, alert.get('ref_id', ''),
                                                                  alert_csv_id)
                alert['alert_data']['csv'] = extracted_csv_data
            outputs.append(alert)
        total_alerts = result.get('total')
        table_headers = ['ref_id', 'title', 'status', 'severity', 'created_date', 'type',
                         'environment']
        readable_output = f'Total alerts: {total_alerts}\nCurrent page: {args.get("page", 1)}\n'
        readable_output += tableToMarkdown(name='CyberInt alerts:', t=outputs, headers=table_headers,
                                           removeNull=True)
        return CommandResults(outputs_key_field='ref_id', outputs_prefix='Cyberint.Alert',
                              readable_output=readable_output, raw_response=result,
                              outputs=outputs)


    def cyberint_alerts_status_update(client: Client, args: dict) -> CommandResults:
        """
            Update the status of one or more alerts

            Args:
            client (Client): Cyberint API client.
            args (dict): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        alert_ids = argToList(args.get('alert_ref_ids'))
        status = args.get('status')
        closure_reason = args.get('closure_reason')
        if status == 'closed' and not closure_reason:
            raise DemistoException('You must supply a closure reason when closing an alert.')
        response = client.update_alerts(alert_ids, status,
                                        closure_reason)
        table_headers = ['ref_id', 'status', 'closure_reason']
        outputs = []
        for alert_id in alert_ids:
            outputs.append({'ref_id': alert_id, 'status': status, 'closure_reason': closure_reason})

        readable_output = tableToMarkdown(name='CyberInt alerts updated information:', t=outputs,
                                          headers=table_headers, removeNull=True)
        return CommandResults(outputs_key_field='ref_id', outputs_prefix='Cyberint.Alert',
                              readable_output=readable_output, raw_response=response,
                              outputs=outputs)


    def cyberint_alerts_get_attachment_command(client: Client, args: dict) -> dict:
        """
        Retrieve attachment by alert reference id and attachment internal id.

        Args:
            client (Client): Cyberint API client.
            args (dict): Command arguments from XSOAR.

        Returns:
            If the API response status is 200 : return attachment file , else return ""

        """

        raw_response = client.get_alert_attachment(args.get('alert_ref_id', None), args.get('attachment_id', None))
        if raw_response.status_code == 200:
            file_entry = fileResult(filename=args.get('attachment_name', None), data=raw_response.content)
            return file_entry
        elif raw_response.status_code == 302:  # have to complete it after getting more info from XSOAR
            return ""
        return ""


    def get_attachment_name(attachment_name):
        """
        Retrieve attachment name or error string if none is provided

        Args:
            attachment_name (str): Attachment name to retrieve

        Returns:
            str: If attachment_name is None or "" - return "demisto_untitled_attachment" , otherwise attachment_name

        """
        if attachment_name is None or attachment_name == "":
            return "demisto_untitled_attachment"
        return attachment_name


    def fetch_incidents(client: Client, last_run: Dict[str, int],
                        first_fetch_time: str, fetch_severity: Optional[List[str]],
                        fetch_status: Optional[List[str]], fetch_type: Optional[List[str]],
                        fetch_environment: Optional[List[str]],
                        max_fetch: Optional[int]) -> Tuple[Dict[str, int], List[dict]]:
        """
        Fetch incidents (alerts) each minute (by default).
        Args:
            client (Client): Cyberint Client.
            last_run (dict): Dict with last_fetch object,
                                      saving the last fetch time(in millisecond timestamp).
            first_fetch_time (dict): Dict with first fetch time in str (ex: 3 days ago).
            fetch_severity (list(str)): Severities to fetch.
            fetch_status (list(str)): Statuses to fetch.
            fetch_type (list(str)): Types to fetch.
            fetch_environment (list(str)): Environments to fetch.
            max_fetch (int): Max number of alerts to fetch.
        Returns:
            Tuple of next_run (seconds timestamp) and the incidents list
        """
        #  Start by setting the time to fetch from.
        last_fetch_timestamp = last_run.get('last_fetch', None)
        if last_fetch_timestamp:
            last_fetch_date = datetime.fromtimestamp(last_fetch_timestamp / 1000)
            last_fetch = last_fetch_date
        else:
            first_fetch_date = dateparser.parse(first_fetch_time)
            last_fetch = first_fetch_date
        incidents = []
        next_run = last_fetch
        #  Send the API request to fetch the alerts.
        alerts = client.list_alerts('1', max_fetch, datetime.strftime(last_fetch, DATE_FORMAT),
                                    datetime.strftime(datetime.now(), DATE_FORMAT), None, None,
                                    fetch_environment, fetch_status, fetch_severity, fetch_type)
        last_file = None
        for alert in alerts.get('alerts', []):
            #  Create the XS0AR incident.
            alert_created_time = datetime.strptime(alert.get('created_date'), '%Y-%m-%dT%H:%M:%S')
            alert_id = alert.get('ref_id')
            alert_title = alert.get('title')
            alert_csv_id = alert.get('alert_data', {}).get('csv', {}).get('id', '')
            if alert_csv_id:
                extracted_csv_data = extract_data_from_csv_stream(client, alert_id,
                                                                  alert_csv_id)
                alert['alert_data']['csv'] = extracted_csv_data
            alert_attachments = alert.get('attachments', [])
            incident_attachments = []
            for attachment in alert_attachments:
                attachment_name = get_attachment_name(attachment.get('name', None))
                attachment_id = attachment.get('id', None)
                if not attachment_id or not alert_id:
                    continue
                get_attachment_response = client.get_alert_attachment(alert_id, attachment_id)
                file_result = fileResult(filename=attachment_name, data=get_attachment_response.content)

                # check for error
                if file_result["Type"] == EntryType.ERROR:
                    demisto.error(file_result["Contents"])
                    raise Exception(file_result["Contents"])

                incident_attachments.append({
                    "path": file_result["FileID"],
                    "name": attachment_name,
                    "showMediaFile": True
                })
            incident = {
                'name': f'Cyberint alert {alert_id}: {alert_title}',
                'occurred': datetime.strftime(alert_created_time, DATE_FORMAT),
                'rawJSON': json.dumps(alert),
                'severity': SEVERITIES.get(alert.get('severity', 'low'), 1),
                'attachment': incident_attachments
            }
            incidents.append(incident)
        if incidents:
            #  Update the time for the next fetch so that there won't be duplicates.
            last_incident_time = incidents[0].get('occurred', '')
            next_run = datetime.strptime(str(last_incident_time), DATE_FORMAT)
        next_run += timedelta(seconds=1)
        next_run_timestamp = int(datetime.timestamp(next_run) * 1000)
        return {'last_fetch': next_run_timestamp}, incidents


    def main():
        """
            PARSE AND VALIDATE INTEGRATION PARAMS
        """
        params = demisto.params()
        access_token = params.get('access_token')
        environment = params.get('environment')

        verify_certificate = not params.get('insecure', False)
        first_fetch_time = params.get('first_fetch', '3 days').strip()
        proxy = params.get('proxy', False)
        base_url = f'https://{environment}.cyberint.io/alert/'
        demisto.info(f'Command being called is {demisto.command()}')
        try:
            client = Client(
                base_url=base_url,
                verify_ssl=verify_certificate,
                access_token=access_token,
                proxy=proxy)

            if demisto.command() == 'test-module':
                result = test_module(client)
                return_results(result)

            elif demisto.command() == 'fetch-incidents':
                fetch_environment = argToList(params.get('fetch_environment', ''))
                fetch_status = params.get('fetch_status', [])
                fetch_type = params.get('fetch_type', [])
                fetch_severity = params.get('fetch_severity', [])
                max_fetch = int(params.get('max_fetch', '50'))
                next_run, incidents = fetch_incidents(
                    client, demisto.getLastRun(), first_fetch_time, fetch_severity, fetch_status,
                    fetch_type, fetch_environment, max_fetch)
                demisto.setLastRun(next_run)
                demisto.incidents(incidents)

            elif demisto.command() == 'cyberint-alerts-fetch':
                return_results(cyberint_alerts_fetch_command(client, demisto.args()))

            elif demisto.command() == 'cyberint-alerts-status-update':
                return_results(cyberint_alerts_status_update(client, demisto.args()))

            elif demisto.command() == 'cyberint-alerts-get-attachment':
                return_results(cyberint_alerts_get_attachment_command(client, demisto.args()))
        except Exception as e:

            if 'Invalid token or token expired' in str(e):
                error_message = 'Error verifying access token and / or environment, make sure the ' \
                                'configuration parameters are correct.'
            elif 'datetime' in str(e).lower():
                error_message = 'Invalid time specified, ' \
                                'make sure the arguments are correctly formatted and are not ' \
                                'earlier than 2020 or later than the current time.'
            elif 'Unauthorized alerts requested' in str(e):
                error_message = 'Some of the alerts selected to update are either blocked or not found.'
            else:
                error_message = f'Failed to execute {demisto.command()} command. Error: {str(e)}'
            return_error(error_message)


    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()
  subtype: python3
  type: python
image: data:image/png;base64,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
tests:
- No tests - Deprecated
fromversion: 5.0.0
